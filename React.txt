
● What is Emmet?

EMMET:
It allows you to type shortcuts that are then expanded into full pieces of code 
Helps you write HTML and CSS faster by using simple abbreviations that are then converted into code blocks.

https://docs.emmet.io/cheat-sheet/

However, there is one minor drawback; by default, Emmet is not enabled for React in VS Code.


● Difference between a Library and Framework?   
JS libraries give developers predefined methods and classes to help them work faster and more efficiently.
 On the other hand, the JS framework acts as a framework for developers to construct apps for specific platforms.

The term "inversion of control" describes the technical distinction between a framework and a library. 
You have complete control over the application's flow when you use a library. You get to decide when and where you want to call the library.
While when using a framework, the flow is controlled by the framework itself. It gives you various locations to plug in your code, 
but it only calls the code you've plugged in when it's needed.

● What is CDN? Why do we use it?
CDN(Content Delivery Network) is a group of servers which work together to provide fast delivery of Internet content.
A CDN allows for the quick transfer of assets needed for loading Internet content including HTML pages, javascript files, stylesheets, images, and videos.
We use it for the following benefits
Improved website loading times
Reducing banwidth costs
Increased content availability
Improving website security

● Why is React known as React?
React was developed for applications (Facebook) that have constantly changing data. 
Since React is a front-end framework or the “View” in MVC, this means that as the user clicks around 
and changes the app’s data, the view should “react” or change with those user events. 
User events being mouse clicks, typing, submitting a form.

● What is crossorigin in script tag?
The crossorigin attribute sets the mode of the request to an HTTP CORS Request. Web pages often make requests to load resources on other servers. 
Here is where CORS comes in. A cross-origin request is a request for a resource (e.g. style sheets, iframes, images, fonts, or scripts) from another domain
If you serve React from a CDN, we recommend to keep the crossorigin attribute set:

<script crossorigin src="..."></script>
We also recommend to verify that the CDN you are using sets the Access-Control-Allow-Origin: 
This enables a better error handling experience in React 16 and later.

● What is diference between React and ReactDOM


react is for the components and react-dom is for rendering the components in the DOM. 
'react-dom' acts as a glue between components and DOM. You will be using render() method of the react-dom to render components in the DOM 
The react package contains React.createElement, React.createClass and React.Component, React.PropTypes, React.Children,
 and the other helpers related to elements and component classes. We think of these as the isomorphic or universal helpers that you need to build components.

The react-dom package contains ReactDOM.render, ReactDOM.unmountComponentAtNode, and ReactDOM.findDOMNode, 
and in react-dom/server we have server-side rendering support with ReactDOMServer.renderToString and ReactDOMServer.renderToStaticMarkup.

● What is difference between react.development.js and react.production.js files via CDN?

Production CDN file of react is just a minified and optimized version that makes rendering of file on end user's browser very quick and performance enhancing.
Development CDN file is solely for local development purposes
It will take more time to build compared to production build

● What is async and defer? -
In async, the html parsing will go on with the script fetching and once that is done it will wait till all scripts executed and then go ahead with the parsing
In defer the html parsing will go on with script fetching , once it fetched it will be stopped and the parsing will finish first and once thats done will the script start execution
Async will not guarantee the order of execution of scripts but defer does
Async is not good with multiple dependent scripts so better to go with defer 
If we have to load some external scripts like mostly Google analytics better to use async

Defer is always a better alternative to async 

1. What is a bundler?
A bundler is a development tool that combines many JavaScript code files into a single one that is production-ready loadable in the browser
For example:
	1. parcel
	2. webpack (used by create-react-app) and
	3. vite ( prounounced as veet)
2. npm :
1. About :
It is a tool used for package managemnet.
Note :
npm does not stand for node package manager but everything else.
	1. npm alternative -> yarn
2. npm setup :
npm init
npm init -y can be used to skip the setup step, npm takes care of it and creates the package.json json file automatically , but without configurations.

3. Difference betweeen package.json and package-lock.json.
	1. package.json :
	• this file is mandatory for every project
	• It contains basicinformation about the project
	• Application name/version/scripts (ng scripts)
	2. package-lock.json :
	• This file is automatically generated for those operations where npm modifies either the node_module tree or package-json.
	• It is generated after an npm install
	• It allows future devs & automated systems to download the same dependencies as the project.
	• it also allows to go back to the past version of the dependencies without actual ‘committing the node_modules folder.
	• It records the same version of the installed packages which allows to reinstall them. Futuee installs wll be capable of building identical description tree.
	3. ~ or ^ in package.json file : These are used with the versions of the package installed.
For example in package.json file:
"dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  }
	• ~ : we can use it for minor version updates for a package.
	• ^ : we can use it for major version updates for a package.
If none of them is present , that means only the version specified in package.json file is used in the development.

3. Parcel:
Parcel is a bundler used for development and productions purposes.
Parcel Features:
	• HMR - Hot Module Replacement - parcel keeps track of file changes via file watcher algorithm and renders the changes in the files
	• File watcher algorithm - made with C++
	• MINIFY
	• BUNDLING
	• Cleaning our code
	• DEV and production Build
	• Super fast building algorithm
	• does image optimization also
	• Caching while development
	• Compresses
	• Compatible with older version of browser
	• HTTPS in dev
	• port Number
	• Consistent hashin algorithm
	• Zero Configuration
installation commands:
	1. Install:
npm install -D parcel
-D is used for development and as a development dependency.
	2. Parcel Commands :
	• For development build:
npx parcel <entry_point> 
	• For production build :
npx parcel build <entry_point> 

4. Why react is fast?
It is not only the virtual DOM that makes React faster but other components like bundlers (e.g. parcel, webpack ,vite etc. ) and development ecosystme also.
5. Transitive dependencies:
It is a type of dependency where one dependency requires another dependency to work properly and another dependency requires an another dependecy.

6. devDependencies vs dependency :
A dependency is a library that a project needs to function effectively. DevDependencies are the packages a developer needs during development.

1. What is JSX?
JSX is a syntex extension created by Facebook. JSX is a JavaScript Extension Syntax used in React to easily write HTML  like code and JavaScript together.
It makes us easy to understand the code and makes the code easy to maintain.
2. Superpowers of JSX.
	• Easy to maintain
	• Secure
	• Easy to debug
3. Role of type attribute in script tag? What options can I use there?
The type attribute in the script tag defines the type of script that we we want to run inside our app. type attribute can be of the following types:
	• text/javascript : It is the basic standard of writing javascript code inside the <script> tag.
e.g
<script type="text/javascript">
    const a = "Hello";
    const b = "World!";
    console.log(a + " " + b); // Hello World!
</script>
	• text/ecmascript : this value indicates that the script is following the EcmaScript standards.
	• module: This value tells the browser that the script is a module that can import or export other files or modules inside it.
	• text/babel : This value indicates that the script is a babel type and required bable to transpile it.
	• text/typescript: As the name suggest the script is written in TypeScript.
4. {TitleComponent} vs {<TitleComponent/>} vs {<TitleComponent></TitleComponent>} in JSX.
	• {TitleComponent}: This value describes the TitleComponent as a javascript variable expession or a value. The {} can embed a javascript expression or a values inside it.
	• <TitleComponent/> : This value represents a Component that is basically returning Some JSX value. in simple terms TitleComponent a function that is returning a JSX value. A compoenet is written inside the {< />} expression.
	• <TitleComponent></TitleComponent> : <TitleComponent /> and <TitleComponent></TitleComponent> are equivalent only when < TitleComponent /> has no children components.The opening and closing tags are created to include the child components.
e.g.
<TitleComponent>
    <ChildComponen1 />
    <ChildComponen2 />
    <ChildComponen3 />
</TitleComponent>

Ques1. Is JSX mandatory for React?
Ans. No, JSX is not mandatory for writing React, but it is suggested to use JSX for having better code readability and clean code.

Ques2. Is ES6 mandatory for React?
Ans. No, Es6 is also not mandatory for React, but it is suggested to use Es6 while writing React as it offers a lot of features for writing better code.

Ques3. How can I write comments in JSX?
Ans. You can use // or /* */ for multi line comments inside {}.

Ques4. What is React.Fragment or <></>
Ans. React.Fragment gives the power of returning multiple children elements without adding the extra nodes to the DOM as the parent. <></> is the shorthand for React.Fragment

Ques5. What is Virtual DOM?
Ans. Virtual DOM is a concept which is a representation of UI kept in memory and synced with real DOM by ReactDOM. This process is called reconciliation.

Ques6. What is Reconciliation?
Ans. Reconciliation is a process where the virtual DOM is synced with actual DOM by reactDOM. React uses Diffing algorithm for performing reconciliation. React uses O(n) approach based on 2 assumptions

Two element of different types will produce different trees.
devs can use key props which makes child element stable and avoid multiple rendering.
The Diffing algorithm
Elements Of Different Types: Different types element will generate 2 different trees at all. In such cases root of the old and new tree is compared and if it is different from React will tear down the old tree and create the new one.
When tearing down a tree, old DOM nodes are destroyed. Component instances receive componentWillUnmount().

When building up a new tree, new DOM nodes are inserted into the DOM. Component instances receive UNSAFE_componentWillMount() and then componentDidMount(). Any state associated with the old tree is lost.

DOM Elements Of The Same Type: In such cases where dom element is of same type and only attribute changes then react will only update the changed attribute.
<div className="before" title="stuff" />

<div className="after" title="stuff" />
only className attribute will be updated in such case.I guess in case of native element and not component.

Component Elements Of The Same Type: When the component element(custom) is same but the props gets changed then the instance gets the same and state is maintained across renders.
<CustomComponent prop1="hello" prop2="2022">

<CustomComponent prop1="hello" prop2="2023">
In such case, only the prop gets updated and internally React updates it to match the new element, and calls UNSAFE_componentWillReceiveProps(), UNSAFE_componentWillUpdate() and componentDidUpdate() on the underlying instance.

Recurring On Children without keys and with keys: Refer next answer
Ques7. Why do we need keys and when we need it?
Ans. In the diffing algorithm used by React, When there is a change in the child elements considering that same child elements gets added or removed, this time react will mutate on each and every child which can create performance issue when multiple nodes are involved.

//Old one
<ul>
    <li>Holi</li>
    <li>Diwali</li>
</ul>

//New one
<ul>
    <li>New year's eve</li>
    <li>Holi</li>
    <li>Diwali</li>
</ul>
In the above example where we add similar children element as before which is li tag, React will not realize that Holi and Diwali are the old existing nodes and will reiterate on all three nodes.

In such cases React comes up with providing key attribute to such nodes where elements are same.

//Old one
<ul>
    <li key={1}>Holi</li>
    <li key={2}>Diwali</li>
</ul>

//New one
<ul>
    <li key={0}>New year's eve</li>
    <li key={1}>Holi</li>
    <li key={2}>Diwali</li>
</ul>
Now, React knows that element with key 0 is the new one and other elements are just moved down.

We need keys to avoid such performance issue which can occur in case of multiple nodes in the application. Also, we should be careful to add more stable keys instead of random keys or indexes which change a lot.

Now, in the above example if we have added a new img tag instead of li tag then this problem would not have came so keys are required only when same elements needs to be added again.

Ques8. What is React Fiber?
Ans. The idea behind developing Fiber is to achieve these goals:

pause work and come back to it later.
assign priority to different types of work.
reuse previously completed work.
abort work if it's no longer needed.
For achieving this we need to breakdown things in unit of work. That's what a fiber is unit of work. When a function executed a new stack frame gets added in call stack so lets say if rendering is happening then browser if render till that stack frame gets completed and hence we cannot do anything there. there are new browsers which have requestIdleCallback schedules a low priority and requestAnimationFrame which have high priority and needs to be called in next animation frame So we need to break down things so that if possible we can hold the rendering stack frame and perform the more important task, but if we depend on call stack, it will keep doing work until the stack is empty.

Fiber is the reimplementation of call stack, specialized for React components. A single fiber can be considered as a virtual stack frame.

for more details: https://github.com/acdlite/react-fiber-architecture

Ques9. Can we use Index as keys?
Ans. Yes, we can use index as keys, but it is not recommended to use index as keys because if arrays element gets reordered so the indexes, and it becomes difficult for react to compare with the old tree and hence react ends up comparing each child element and that key will not be of much use.

Giving keys as index is still better than not giving keys at all. For more details: https://robinpokorny.com/blog/index-as-a-key-is-an-anti-pattern/

Ques10. What is props in React?
Ans. Props are the properties of a React component that can be passed from parent to Child component. we can consider it as a attributes of html element but here we can also have custom attributes as props.

Ques11: What is config Driven UI?
Ans. Controlling UI from backend data coming from API is basically known as config driven ui where we gets config details from backend apis which decides what ui to displays. e.g., If swiggy is providing offers in city1 but not in city2 the carousel for offers should come only for city 1 and these information ui will get from backend in config form


1) what is difference between Named Export, Default Export and * as Export?
ES6 provides us to import a module and use it in other files.

ES6 provides 2 ways to export a module from file.

1) Named Export:

Using named export we can export any number of exports per file and we can import specific export by putting it in the braces. "The imported name should be the same as the name of the exported module".
example:
//imported a single named export.
import { MyComponent } from './MyComponent';

//importing multiple named export
import { MyComponent1, MyComponent2 } from './MyComponent';

//giving a named import a different name by using 'as'
import { MyComponent2 as MyNewComponent } from './MyComponent'; this is called opt-in Alisaing

//export from ./MyComponent.js file
export const MyComponent1 = () => {...}
export const MyComponent2 = () => {...}

export using * as:
We can also Import all the named exports onto an object:

import * as MainComponent from './MyComponent.js';
MainComponent.MyComponent1();
MainComponent.MyComponent2();

Default Export: (export default)
using default export we can only do one export per file, which will acts as main export.

//Import
import MyDefaultCompoent from "./MyDefaultComponent";

//Export
const MyComponent  = () => {...};
export default MyComponent;

Note: we can give any name from a default export while importing.

https://medium.com/@etherealm/named-export-vs-default-export-in-es6-affb483a0910#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6ImEyOWFiYzE5YmUyN2ZiNDE1MWFhNDMxZTk0ZmEzNjgwYWU0NThkYTUiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJuYmYiOjE2NzM1MDU5MjQsImF1ZCI6IjIxNjI5NjAzNTgzNC1rMWs2cWUwNjBzMnRwMmEyamFtNGxqZGNtczAwc3R0Zy5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsInN1YiI6IjExMjQyOTMxNTQwMjU1NTg2ODMwOSIsImVtYWlsIjoidmFyZGhpbmVlZGlnYW5kaGlAZ21haWwuY29tIiwiZW1haWxfdmVyaWZpZWQiOnRydWUsImF6cCI6IjIxNjI5NjAzNTgzNC1rMWs2cWUwNjBzMnRwMmEyamFtNGxqZGNtczAwc3R0Zy5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsIm5hbWUiOiJ2ZW5rYXQgdiIsInBpY3R1cmUiOiJodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5jb20vYS9BRWRGVHA3TmFzMGtJSF9uRGhqQms1S1RzZDVKbVB3NFNENkdxUjJxajVTclhnPXM5Ni1jIiwiZ2l2ZW5fbmFtZSI6InZlbmthdCIsImZhbWlseV9uYW1lIjoidiIsImlhdCI6MTY3MzUwNjIyNCwiZXhwIjoxNjczNTA5ODI0LCJqdGkiOiJjMDM2OWQxZDQ4NWM0NmUzMzMyNzVjZTYwNTc4NzA2ZmIwM2UwNGNhIn0.emY6avkrgaGdtPHQvF7jmPAlc7PJH_hH8n4_4cJ-aqNxkwUtbBb96t9-E6dOyRgfnL3iDzrJtNOG9SbcSNylX-A3oc9ma-hYS4ENSbcC1P1eDZ9r7M_IIdofFfMnXbJKPUZ7saP0x1-t5SF7zQV3euM2K2Qu90496iczOg25I31zVmjq-tlDUvs9FCGuXHMIs_4ivLOVo8bnTR7QJnhVGIufJvBjeMIWEEgqfdpV_ZuILyrsmOcvfg4Si-Bex7bpaOUw9rmL9jvIyeCBSzdG8FsEqbmSrum2eBgeqxXLQwfNj1J559VcRbeWwMF68oo4XQ-jQAP9-ZR7u7DMsjcWgA
https://betterprogramming.pub/understanding-the-difference-between-named-and-default-exports-in-react-2d253ca9fc22#:~:text=Exports%20without%20a%20default%20tag,are%20not%20React%2Dcentric%20ideas.


2) What is the importance of config.js file?

Ans) Config.js file allows developers to configure the application instead of hard-cording the values in the code. There will be come values which be unaltered and will be use across the application. So instead of hard-cording those values.
we can put them in the Config.js file and we can use those values across the application. when ever required we can modify it at one place and will get reflected all around the application.

https://www.useragentman.com/blog/config-js-%E2%80%93-a-javascript-cofiguration-library/#:~:text=Description-,Config.,%2C%20numbers%2C%20arrays%20and%20HTML.

3) What are React Hooks?

Ans)  React Hooks are plain javascript functions that we can isolate the reusable logic from the functional component. He the hooks can be the stateful logic and can manage the side-effect logic.

4) Why do we need a useState Hook?

Ans) useSate is one of the React Hooks, which is used to maintain the react local state variables, from creation to updation.

let [stateVariable, setStateVaiable ] = useState("xyz");

the above is the syntax of it.

here the value passed to useState will be the default value fir the state variable. and it will return array which consists of a state varaible and a function to update the state variable.


1) What is Microservices?

Ans) A microservice is a architectural pattern which has emerged from the world of domain-driven design, continuous delivery, platform and infracturcture automation, scalable sysytems, polyglot programming and persistance.


A microservice architecture (newer model for application development) where  we group up the main functionalities into services instead of maintaining them under one application. these loosly coupled services which can be deployed, and maintained independently. each of these service is responsible for discrete task and can communicate with other service through simple APIs to solve a larger complex problem.

Key Benifits:

1) As the constituent (part of the whole application) services are small, they can be built by one or more small teams from scratch seperated by service boundaries which makes it easier to scaleup.

2)Once developed, these services can be deployed independantly of each other and we can easy to identify the hot services and scale them independantly of whole application.
fault isolation is easier and whole application won't stop working if one service has error. we can fix it the error and redeploy that service instead of the whole application.

3)Another advantage is we can use multiple technologies to develop the service, there is no need of limiting to one technology. we can use the best technology for that service to acheive specific functionality.

Reference: https://medium.com/hashmapinc/the-what-why-and-how-of-a-microservices-architecture-4179579423a9

2) What is  Monolith architecture?

Ans) Monolithic architecture is the traditional structure for software application.

Monolithic is an all-in-one architecture, where in all aspects of the software operate as a single unit. 

Monolithic architecture is a unified development model for software application. It has 3 components:

1) Client-side user interface
2) Server-side application
3) Data interface

All there parts interact with a single database.Software built on this model operates with one base of code.


Pros:
1)It's easier to take care of issues that affect the whole application.(caching, logging, performance monitoring, and handling. basically easier to manage).
2)It's easier to test and debug. (as everything is at one place end-to-end testing is easier).
3)It's easier to deploy and develop. (it requires only one file or directory. so deployment is easier).

Cons:
1)It's hard to scale or change. (as everything is at one place, changes must involve the entire architecture. The entire application must scale all at once).
2)The code becomes complicated. (as all in one base code, it will become increasingly complex as the application grows and changes).
3)It's challenging to integrate with new technology. (as all the application lies in one base code, it's difficult to integrate. the code rewrite from scratch should accommodate).

Reference : https://www.integrate.io/glossary/what-is-monolithic-architecture/

3) What is the difference between Monolith and Microservice?

Ans)    Monolithic Vs Microservice

A monolithic software application may be a simple office suite software program for individual user.
monolithic connects to single database.

A microservices operates as a loose collection of functionalities (known as services) that work together under the basket of a single application. each service is deployed into there own cloud-based environment and single team dedicated to it.

Reference : https://www.integrate.io/glossary/what-is-monolithic-architecture/

4) Why do we need a useEffect Hook?

Ans) The useEffect Hook lets you perform side effect in react function components.

What is a react side-effect?
A react side-effect occurs when we use something that is outside the scope of Rect.jsin our React components.

Eg:- Browser APIs like localStorage.

outside the scope means that is not part of the react framework.

when we use react with any of the Browser's api such as the local storage, we are creating a side-effect by storing some value in the local storage.

useEffect(() => {
localStorage.setItem('some key', true); 
}, []);

if we use the native DOM methods instead of the ReactDOM is another exmple of creating side-effect.
calling the API using fetch.

Effetively managing it is the key facter. by keeping track of the changes in the side-effects.

Why do we nee useEffect??

by using this Hook, you tell React that your component needs to do something after render. React will remember the function you passed. that callback function is treated as side-effect.
and call it later after performing the DOM updates.It will be called once after the intial render (later after performing the DOM updates) and every-time state change detection rerender.


we can acheive thing inthe Life -cycles also but it fources usto split the logic even through conceptually code in both of them is related to the same effect. or repeating the logic even thought the the effect is same.

Syntax: useEffect(callBackFn,[`dependency array`]);

function callBackFn() {
    {...}//internal logic or effect logic.
    return () => {clean-up logic}//optional
}

the side-effect logic may return a function. this is a optional cleanup mechanism for effects. every effect may return a function that cleans up after it.

When exactly it will be called? React cleanup when the component unmounts, However as we know, effects run for every render and not just once. This is why React also cleans from the previous render before running the effects next time.

Reference: https://reactjs.org/docs/hooks-effect.html
https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/

5) What is Optional Chaining?

The optional chaining (?.) operator accesses an object's property or calls a function. If the object accessed or function called is undefined or null, it returns undefined instead of throwing an error.

const god = {
    name: 'Indra',
    consert: 'sachi',    
};

const consert = god?.consert; //sachi

const vahana = god?.vahana; //undefined property

console.log(god.Powers?()); //undefined function

console.log(god.wepoans?[0]); //undefined array

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining

6) What is Shimmer UI?

Ans) A Shimmer UI resembles the page's actual UI, so users will understand how quickly the web or mobile app will load even before the content has shown up. It gives people an idea of what's about to come and what's happening (it's currently loading) when a page full of content/data takes a while to load.

Basically moadren form of loader.

7) What is the difference between JS expression and JS statement.

Ans) a Js expression is a bit of JavaScript code that produces a value.

example: 1, "Hi", 5*5, num> 100, isHappy ? :) : :( , [1,2,3].pop(),

A JavaScript program is a sequence of statements. Each statement is an instruction for the computer to do something.

exmaple: let hi = 5; if(hi > 10) { //More statements here }; throw new Error('...');

statement often have "slots" for expression. we can put any expression we like into those slots.

statements and expression are not same.

In a JSX we have {} where we can only put valid Js expresion. If we try to put a statement we will get an syntax error.

because statement never returns a value but expresion did. for conditions we may use terinary operater.

8) What is Conditional Rendering, explain with a code example?

Sometimes we need to switch betwwen the components or show hide the components based on the state.

So here to acheive that React provides a concept known as conditional rendering. It works exactly same way conditions work in JS.

Example:

const login =  (prop) => { <button onClick={props.onClick}>
      Logout
    </button>};
const logout =  (prop) => { <button onClick={props.onClick}>
      Login
    </button>};

const Button = (prop) => {
    const isLoggedIn = prop.isLoggedIn;

    if(isLoggedIn){
        return <UserGreeting/>
    }
    else{
         return <GuestGreeting/>   
    }
}

or we can use element variable (where we can store the element in a variable and use operater)
or we can use terinary operater with in the embed expresion in JSX. ({})
or we can use Logical && operator with in the embed expresion in JSX.

Reference: https://reactjs.org/docs/conditional-rendering.html#:~:text=In%20React%2C%20you%20can%20create,way%20conditions%20work%20in%20JavaScript.

9) What is CORS?
ans) Cross-Origin Resource Sharing (CORS) is a HTTP-header based mechanism that allows a server to indicate any origin (domain,scheme, or post) other than its own from which a Browser should should permit loading resources.

CORS relies on the mechanism by which Browser make a "Preflight" request to the server hosting the Cross-Origin resource, In order to check that the server will permit the actual request.

resource: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS

10) What is async and await? 

ans) async function can contain zero or more await expresion. Await expresios makes promise-returning function behave as thoght they're synchronous by suspending execution until the returned promise is fulfilled or rejected. the resolved value of the promise is treated as the return value of the await expressiom. Use of the asyunc and await enables the use of ordinary try/catch block around asynchronous code.

Reference: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function#:~:text=The%20async%20and%20await%20keywords,also%20be%20defined%20as%20expressions.

11) What is the use of `const json = await data.json();` in  getRestaurants()?
ans) here we are trying to get the JSON object which is the response for the API call. but fetch doesn't return the JSON response body but instead returns a promise that resolves with a Response object.

The Response object, in turn, does not directly contain the actual JSOM response body but is instead a representation of the entire HTTP response. So, to extract the JSON body content from the Response object, we use the json() method, which returns a second promise that resolves with the result of parsing the response body test as JSON.



1. What are various ways to add images into our App? Explain with code examples
Using the full URL of the image for the web (CDN) or any public images.
Example : <img src="https://reactjs.org/logo-og.png" alt="React Image" />

Adding the image into the project Drag your image into your project and import it into the desired component
import reactLogo from "./reactLogo.png";

export default function App() {
  
  return <img src={reactLogo} alt="react logo" />
}
The correct way to structure images in your project is to add them in an images folder. If you are using other assets than just images, you might want to add all the assets folders.
import reactLogo from "../../assets/images/reactLogo.png";

export default function App() {
  
  return <img src={reactLogo} alt="react logo" />
}
2. What would happen if we do console.log(useState())?
If we do console.log(useState()), we get an array [undefined, f] where first element state is undefined and the setState function is bound dispatchSetState.

3. How will useEffect behave if we don't add a dependency array ?
Syntax : useEffect(setup,[dependencies]? )

Case 1 : useEffect(setup) When the dependency array is not included in the arguments of useEffect() hook, the setup function will be executed every time the component is rendered and re-rendered.

Case 2 : useEffect(setup,[]) When the dependency array is empty in the arguments of useEffect() hook, the setup function will be executed only one time during the initial render of the component.

Case 3 : useEffect(setup, [state]) When the dependency array contains an array of states, the setup function will be executed one time during the initial render of the component and also whenever there is a change in the state.

4. What is SPA?
Single Page Application (SPA) is a web application that dynamically updates the webpage with data from web server without reloading/refreshing the entire page. All the HTML, CSS, JS are retrieved in the initial load and other data/resources can be loaded dynamically whenever required. Example : Facebook is a Single Page Application which loads lot of components and refreshes only the required component.

5. What is difference between Client Side Routing and Server Side Routing?
In Server-side routing or rendering (SSR), every change in URL, http request is made to server to fetch the webpage, and replace the current webpage with the older one.

In Client-side routing or rendering (CSR), during the first load, the webapp is loaded from server to client, after which whenever there is a change in URL, the router library navigates the user to the new page without sending any request to backend. All Single Page Applications uses client-side routing.
